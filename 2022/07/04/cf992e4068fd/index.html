<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>跳表 · 风吹流年远</title><meta name="description" content="跳表（SkipList）wiki
发明者论文: Skip lists: a probabilistic alternative to balanced trees
参考文章1
参考文章2



算法
平均
最差



空间
O(n)
O(n log n)[1]


搜索
O(log n)
O(n)["><meta name="og:description" content="跳表（SkipList）wiki
发明者论文: Skip lists: a probabilistic alternative to balanced trees
参考文章1
参考文章2



算法
平均
最差



空间
O(n)
O(n log n)[1]


搜索
O(log n)
O(n)["><meta name="twitter:site" content="风吹流年远"><meta name="twitter:title" content="跳表"><meta name="twitter:card" content="summary"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 5.1.1"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title">Time went by</a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">风吹流年远</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/categories">Categories</a></li><li><a href="/tags">Tags</a></li><li class="soc"><a href="https://github.com/luoochen" target="_blank" rel="noopener noreferrer" aria-label="Github"><i class="fa fa-github">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2022&nbsp;<a target="_blank" href="https://luoochen.github.io" rel="noopener noreferrer">Luoo</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>跳表</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2022-07-04</span><span class="meta-item"><i class="fa fa-folder"></i><span>&nbsp;</span><a href="/categories/CS/" title="CS" class="a-tag">CS</a><span>&nbsp;</span></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/数据结构/" title="数据结构" class="a-tag">数据结构</a><span>&nbsp;</span></span></p><p class="post-abstract"><html><head></head><body><h1 id="跳表（SkipList）"><a href="#跳表（SkipList）" class="headerlink" title="跳表（SkipList）"></a>跳表（SkipList）</h1><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B7%B3%E8%B7%83%E5%88%97%E8%A1%A8">wiki</a></p>
<p><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=cjdMGYKBTiCTm53egGSYJg==.9VAB7c+Vqc6UvOs0QgUo/vBkneUNRz8c8lk9hrciyLJZFLLux7E9wWjw8Azb25FYBjqSQZFuU2iO2Uw3KLpsALnI5OUkFftdbJfY8biceV/P4AvgUnU+L8cxL5fc+Jdp">发明者论文: Skip lists: a probabilistic alternative to balanced trees</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/125767246">参考文章1</a></p>
<p><a target="_blank" rel="noopener" href="http://igoro.com/archive/skip-lists-are-fascinating/">参考文章2</a></p>
<table>
<thead>
<tr>
<th>算法</th>
<th><strong>平均</strong></th>
<th><strong>最差</strong></th>
</tr>
</thead>
<tbody><tr>
<td>空间</td>
<td>O(<em>n</em>)</td>
<td>O(<em>n</em> log <em>n</em>)[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B7%B3%E8%B7%83%E5%88%97%E8%A1%A8#cite_note-cs.uwaterloo-1">1]</a></td>
</tr>
<tr>
<td>搜索</td>
<td>O(log <em>n</em>)</td>
<td>O(<em>n</em>)[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B7%B3%E8%B7%83%E5%88%97%E8%A1%A8#cite_note-cs.uwaterloo-1">1]</a></td>
</tr>
<tr>
<td>插入</td>
<td>O(log <em>n</em>)</td>
<td>O(<em>n</em>)</td>
</tr>
<tr>
<td>删除</td>
<td>O(log <em>n</em>)</td>
<td>O(<em>n</em>)</td>
</tr>
</tbody></table>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算机科学</a>中，<strong>跳表</strong>是一种<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a>。它使得包含n个元素的有序<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BA%8F%E5%88%97">序列</a>的查找和插入操作的平均时间复杂度都是$O(\log{n})$，优于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E7%BB%84">数组</a>的$O(n)$复杂度。</p>
<p>快速的查询效果是通过维护一个多层次的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8">链表</a>实现的，且与前一层（下面一层）链表元素的数量相比，每一层链表中的元素的数量更少。一开始时，算法在最稀疏的层次进行搜索，直至需要查找的元素在该层两个相邻的元素中间。这时，算法将跳转到下一个层次，重复刚才的搜索，直到找到需要查找的元素为止。跳过的元素的方法可以是随机性选择[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B7%B3%E8%B7%83%E5%88%97%E8%A1%A8#cite_note-pugh-2">2]</a>或确定性选择[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B7%B3%E8%B7%83%E5%88%97%E8%A1%A8#cite_note-3">3]</a>，其中前者更为常见。</p>
<img src="/2022/07/04/cf992e4068fd/2560px-Skip_list.svg.png" alt="img" style="zoom:80%;">

<blockquote>
<p>一张跳跃列表的示意图。每个带有箭头的框表示一个指针, 而每行是一个稀疏子序列的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8">链表</a>；底部的编号框（黄色）表示有序的数据序列。查找从顶部最稀疏的子序列向下进行, 直至需要查找的元素在该层两个相邻的元素中间。</p>
</blockquote>
<p>跳表是一种可以用来代替平衡树的数据结构，跳表使用概率平衡而不是严格执行的平衡，因此，与等效树的等效算法相比，跳表中插入和删除的算法要简单得多，并且速度要快得多。</p>
<p>跳跃列表不像<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B9%B3%E8%A1%A1%E6%A0%91">平衡树</a>等数据结构那样提供对最坏情况的性能保证：由于用来建造跳跃列表采用随机选取元素进入更高层的方法，在小概率情况下会生成一个不平衡的跳跃列表（最坏情况例如最底层仅有一个元素进入了更高层，此时跳跃列表的查找与普通列表一致）。但是在实际中它通常工作良好，随机化平衡方案也比平衡二叉查找树等数据结构中使用的确定性平衡方案容易实现。跳跃列表在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97">并行计算</a>中也很有用：插入可以在跳跃列表不同的部分并行地进行，而不用对数据结构进行全局的重新平衡。</p>
<h2 id="算法核心思想"><a href="#算法核心思想" class="headerlink" title="算法核心思想"></a>算法核心思想</h2><h3 id="理想状态的多层次链表"><a href="#理想状态的多层次链表" class="headerlink" title="理想状态的多层次链表"></a>理想状态的多层次链表</h3><p>对于一个链表来说，如果要查找某个元素，我们可能需要遍历整个链表(图Figure1 a)。</p>
<p>如果链表是有序的，并且每两个节点都有一个指针指向它之后两位的节点(图Figure1 b)，那么我们可以通过查找不超过 <code>⌈n/2⌉+1</code> 个节点来完成查找。</p>
<p>如果每四个节点都有一个指针指向其之后四位的节点，那么只需要检查最多 <code>⌈n/4⌉+2</code> 个节点(图Figure1 c)。</p>
<p>如果所有的第($2^i$)个节点都有一个指针指向其$2^i$之后的节点(图Figure1 d)，那么最大需要被检查的节点个数为$⌈log_n2⌉$，代价仅仅是将需要的指针数量加倍。</p>
<p><strong>这种数据结构的查询效率很高，但是对它的插入和删除之后，由于需要重新维护成这样的结构，这几乎是不可实现（impractical）</strong>。</p>
<img src="/2022/07/04/cf992e4068fd/image-20220726180324255.png" alt="image-20220726180324255" style="zoom:80%;">

<h3 id="随机分布的多层次链表"><a href="#随机分布的多层次链表" class="headerlink" title="随机分布的多层次链表"></a>随机分布的多层次链表</h3><p>我们把具有<code>k</code>个指针（指向之后节点）的节点称为<code>k</code>层级节点（即同时位于第1~k层次链表的节点）。各个节点级别的简单分布模式为：50%是1层级，25%是2层级，12.5%是3层级，依此类推。（即一个节点，每向上一层级的概率都相同例如50%，概率可以调整，一般用常数变量<code>p</code>表示。）节点的层级是随机选择的，但比例相同(如下图)。插入或删除节点只需要进行本地局部修改，不需要重新维护整体数据结构；插入节点时随机选择的节点层级一直固定不变。</p>
<img src="/2022/07/04/cf992e4068fd/image-20220726181434351.png" alt="image-20220726181434351" style="zoom:80%;">

<p>因为这样的数据结构是基于链表的，并且额外的指针会跳过中间节点，所以作者称之为<strong>跳表（Skip Lists）</strong>。</p>
<h2 id="原理证明"><a href="#原理证明" class="headerlink" title="原理证明"></a>原理证明</h2><h3 id="最大层级（MaxLevel）"><a href="#最大层级（MaxLevel）" class="headerlink" title="最大层级（MaxLevel）"></a>最大层级（MaxLevel）</h3><p>参考论文论证结果：<br>$$<br>MaxLevel = \log_{\frac{1}{p}}{n}<br>$$<br>其中<code>p</code>为概率常数（即节点每向上涨一层级的概率），<code>n</code>为跳表存储的实际数据量。</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>参考论文论证结果：<br>$$<br>c = \frac{1}{p}\log_{\frac{1}{p}}{n}<br>$$<br>其中<code>c</code>表示搜索实际步数，<code>p</code>为概率常数，因此时间复杂度为$O(\log{n})$。</p>
<h3 id="时间与空间的取舍"><a href="#时间与空间的取舍" class="headerlink" title="时间与空间的取舍"></a>时间与空间的取舍</h3><p>跳表可以通过概率常数 <code>p</code> 的调整，进行时间与空间上的取舍。下图为论文原图：</p>
<img src="/2022/07/04/cf992e4068fd/image-20220727230849105.png" alt="image-20220727230849105" style="zoom:80%;">

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/6/docs/api/java/util/concurrent/ConcurrentSkipListSet.html">Java类库中的跳表实现ConcurrentSkipListMap和ConcurrentSkipListSet</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/LuooChen/algorithms/blob/master/dataStructure/SkipList/SkipList.java">跳表实现-GitHub</a></p>
<p>例如，一个跳表包含 <code>[30, 40, 50, 60, 70, 90]</code> ，然后增加 <code>80</code>、<code>45</code> 到跳表中，以下图的方式操作：</p>
<img src="/2022/07/04/cf992e4068fd/Skip_list_add_element-en.gif" alt="img">

<h3 id="计算跳表的最大层级（MaxLevel）"><a href="#计算跳表的最大层级（MaxLevel）" class="headerlink" title="计算跳表的最大层级（MaxLevel）"></a>计算跳表的最大层级（MaxLevel）</h3><p>一般来说需要按照跳表中将要存储的数据量 $n$ 的大小计算<a href="#%E6%9C%80%E5%A4%A7%E5%B1%82%E7%BA%A7%EF%BC%88MaxLevel%EF%BC%89">跳表的最大层级（MaxLevel）</a>。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">private static int calculateMaxLevel(int cap) {
    double maxLevel = Math.log(cap) / Math.log(1/SKIPLIST_P);
    return (int)Math.ceil(maxLevel);
}</code></pre>

<h3 id="随机节点层级"><a href="#随机节点层级" class="headerlink" title="随机节点层级"></a>随机节点层级</h3><p>在创建每个新节点时，通过随机函数，确定每个节点的层级。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">/**
  * 随机获得节点层级
  * 理论来讲，一级索引中元素个数应该占原始数据的 50%，二级索引中元素个数占 25%，三级索引12.5% ，一直到最   * 顶层。因为这里每一层的晋升概率是 50%。对于每一个新插入的节点，都需要调用 randomLevel 生成一个合理的   * 层数。该 randomLevel 方法会随机生成 1~MAX_LEVEL 之间的数，且：
  *      50%的概率返回   1
  *      25%的概率返回   2
  *      12.5%的概率返回 3
  *      ...
  * @return
  **/
private int randomLevel() {
    int level = 1;
    while (Math.random() &lt;= SKIPLIST_P &amp;&amp; level &lt; this.maxLevel) {
        level++;
    }
    return level;
}</code></pre>

<h3 id="搜索（get）"><a href="#搜索（get）" class="headerlink" title="搜索（get）"></a>搜索（get）</h3><p>如图所示，我们检索19这个值，遍历路径如下图所示，可以看到高层级的节点相当于一个快速通道，让搜索进行了节点的跳跃，而不是一个个的遍历。</p>
<img src="/2022/07/04/cf992e4068fd/image-20220727191050619.png" alt="image-20220727191050619" style="zoom:80%;">

<p>搜索实现按照上面的思路，从顶层往下遍历，每层之间就是普通链表遍历。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public T get(Integer key) {
    if (key == null) throw new NullPointerException();
    SkipNode&lt;T&gt; cur = this.head;
    for (int l = maxLevel - 1; l &gt;= 0; l--) {
        while (cur.forwards[l] != null &amp;&amp; cur.forwards[l].key &lt; key) {
            cur = cur.forwards[l];
        }
    }
    if (cur.forwards[0] != null &amp;&amp; key.equals(cur.forwards[0].key)) {
        return (T)cur.forwards[0].value;
    } else {
        return null;
    }
}</code></pre>

<h3 id="插入（set）"><a href="#插入（set）" class="headerlink" title="插入（set）"></a>插入（set）</h3><p>插入的思路是要找到插入的点，并且在遍历的同时，记录下需要更新层数 快速通道指针的地方，在最后进行处理。</p>
<img src="/2022/07/04/cf992e4068fd/image-20220727190840461.png" alt="image-20220727190840461" style="zoom:80%;">

<p>例如插入17，并且在17节点随机获得层数是2.这样节点9的第2层（从下往上数）需要指向新的节点17，12的第1层也要指向17。可以看出需要更新的就是每一层最后遍历过的节点。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean set(Integer key, T value) {
    if (key == null) throw new NullPointerException();
    int newNodeMaxLevel = randomLevel();
    SkipNode&lt;T&gt; newNode = new SkipNode&lt;T&gt;(key, value, newNodeMaxLevel);
    SkipNode&lt;T&gt; cur = head;
    SkipNode&lt;T&gt;[] update = (SkipNode&lt;T&gt;[])new SkipNode[newNodeMaxLevel];//记录更新的节点
    // 遍历找到插入的节点，并记录下需要更新层指针的节点
    for (int l = this.maxLevel - 1; l &gt;= 0; l--) {
        while (cur.forwards[l] != null &amp;&amp; cur.forwards[l].key &lt; key) {
            cur = cur.forwards[l];
        }
        if (cur.forwards[l] != null &amp;&amp; key == cur.forwards[l].key) {
            return false;
        }
        if (l &lt; newNodeMaxLevel) {
            update[l] = cur;
        }
    }
    // 执行插入更新操作
    for (int l = 0; l &lt; newNodeMaxLevel; l++) {
        newNode.forwards[l] = update[l].forwards[l];
        update[l].forwards[l] = newNode;
    }
    return true;
}</code></pre>

<h3 id="删除（remove）"><a href="#删除（remove）" class="headerlink" title="删除（remove）"></a>删除（remove）</h3><p>需要记录下搜索的过程中每一层最后遍历的节点。在找到删除节点后，把每一层中指向删除节点的 指针指向被删除节点每层的后续指针。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public void remove(Integer key) {
    if (key == null) throw new NullPointerException();
    SkipNode&lt;T&gt; cur = head;
    SkipNode&lt;T&gt;[] update = (SkipNode&lt;T&gt;[])new SkipNode[this.maxLevel];
    // 遍历找到要删除的节点，并记录下需要更新层指针的节点
    for (int l = this.maxLevel - 1; l &gt;= 0; l--) {
        while (cur.forwards[l] != null &amp;&amp; cur.forwards[l].key &lt; key) {
            cur = cur.forwards[l];
        }
        update[l] = cur;
    }
    cur = cur.forwards[0];
    if (cur == null || !key.equals(cur.key)) return;
    for (int l = 0; l &lt; this.maxLevel; l++) {
        if (update[l].forwards[l] != cur) {
            break;
        }
        update[l].forwards[l] = cur.forwards[l];
    }
}</code></pre></body></html></p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></span><span class="soc"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></span><span class="soc"><a target="_blank" rel="noopener" href="http://twitter.com/home?status=https://luoochen.github.io/2022/07/04/cf992e4068fd/%20风吹流年远%20跳表" class="fa fa-twitter"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/2022/07/04/bf07598eb9c9/" title="线段树"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: 线段树</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/2021/07/04/4db3a9983678/" title="位运算">Next post: 位运算&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2022&nbsp;<a target="_blank" href="https://luoochen.github.io" rel="noopener noreferrer">Luoo</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>