<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>并查集 · 风吹流年远</title><meta name="description" content="并查集(Disjoint-set data structure&amp;#x2F;Union-find data structure)并查集-wiki
概念在计算机科学中，并查集（英文：Disjoint-set data structure，直译为不交集数据结构）是一种数据结构，用于处理一些不交集（Disj"><meta name="og:description" content="并查集(Disjoint-set data structure&amp;#x2F;Union-find data structure)并查集-wiki
概念在计算机科学中，并查集（英文：Disjoint-set data structure，直译为不交集数据结构）是一种数据结构，用于处理一些不交集（Disj"><meta name="twitter:site" content="风吹流年远"><meta name="twitter:title" content="并查集"><meta name="twitter:card" content="summary"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.1.1"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title">Time went by</a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">风吹流年远</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/categories">Categories</a></li><li><a href="/tags">Tags</a></li><li><a href="/me/index.html">Me</a></li><li class="soc"><a href="https://github.com/luoochen" target="_blank" rel="noopener noreferrer" aria-label="Github"><i class="fa fa-github">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2022&nbsp;<a target="_blank" href="https://luoochen.github.io" rel="noopener noreferrer">Luoo</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>并查集</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2022-07-04</span><span class="meta-item"><i class="fa fa-folder"></i><span>&nbsp;</span><a href="/categories/CS/" title="CS" class="a-tag">CS</a><span>&nbsp;</span></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/数据结构/" title="数据结构" class="a-tag">数据结构</a><span>&nbsp;</span></span></p><p class="post-abstract"><h1 id="并查集-Disjoint-set-data-structure-x2F-Union-find-data-structure"><a href="#并查集-Disjoint-set-data-structure-x2F-Union-find-data-structure" class="headerlink" title="并查集(Disjoint-set data structure&#x2F;Union-find data structure)"></a>并查集(Disjoint-set data structure&#x2F;Union-find data structure)</h1><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86">并查集-wiki</a></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算机科学</a>中，<strong>并查集</strong>（英文：Disjoint-set data structure，直译为不交集数据结构）是一种<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a>，用于处理一些<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%8D%E4%BA%A4%E9%9B%86">不交集</a>（Disjoint sets，一系列没有重复元素的集合）的合并及查询问题。并查集支持如下操作：</p>
<ul>
<li>查询：查询某个元素属于哪个集合，通常是返回集合内的一个“代表元素”。这个操作是为了判断两个元素是否在同一个集合之中。</li>
<li>合并：将两个集合合并为一个。</li>
<li><em>添加</em>：添加一个新集合，其中有一个新元素。添加操作不如查询和合并操作重要，常常被忽略。</li>
</ul>
<p>例如，添加了8个元素，每个元素位于它自己的集合中。 </p>
<img src="https://luoochen.github.io/2022/07/04/3b1471531eae/2560px-Dsu_disjoint_sets_init.svg.png" style="zoom:50%;">

<p>在几次合并操作后，一些集合合并在一起。</p>
<img src="https://luoochen.github.io/2022/07/04/3b1471531eae/2560px-Dsu_disjoint_sets_final.svg.png" alt="img" style="zoom:25%;">

<h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/93647900">并查集-原文</a></p>
<p>并查集的重要思想在于，<strong>用集合中的一个元素代表集合</strong>。</p>
<p>有一个有趣的比喻，把集合比喻成<strong>帮派</strong>，而代表元素则是<strong>帮主</strong>。接下来我们利用这个比喻，看看并查集是如何运作的。</p>
<h3 id="朴素版本"><a href="#朴素版本" class="headerlink" title="朴素版本"></a>朴素版本</h3><p>先看一下朴素版本下的并查集如何运作。（利用帮派比喻）</p>
<p>最开始，所有大侠各自为战。他们各自的帮主自然就是自己。<em>（对于只有一个元素的集合，代表元素自然是唯一的那个元素）</em></p>
<img src="https://luoochen.github.io/2022/07/04/3b1471531eae/image-20220730165903781.png" alt="image-20220730165903781" style="zoom: 25%;">

<p>现在1号和3号比武，假设1号赢了（这里具体谁赢暂时不重要），那么3号就认1号作帮主<em>（合并1号和3号所在的集合，1号为代表元素）</em>。</p>
<img src="https://luoochen.github.io/2022/07/04/3b1471531eae/image-20220730170036012.png" alt="image-20220730170036012" style="zoom:25%;">

<p>现在2号想和3号比武<em>（合并3号和2号所在的集合）</em>，但3号表示，别跟我打，让我帮主来收拾你<em>（合并代表元素）</em>。不妨设这次又是1号赢了，那么2号也认1号做帮主。</p>
<img src="https://luoochen.github.io/2022/07/04/3b1471531eae/image-20220730170057899.png" alt="image-20220730170057899" style="zoom:25%;">

<p>现在我们假设4、5、6号也进行了一番帮派合并，江湖局势变成下面这样：</p>
<img src="https://luoochen.github.io/2022/07/04/3b1471531eae/image-20220730170134081.png" alt="image-20220730170134081" style="zoom:25%;">

<p>现在假设2号想与6号比，跟刚刚说的一样，喊帮主1号和4号出来打一架（帮主真辛苦啊）。1号胜利后，4号认1号为帮主，当然他的手下也都是跟着投降了。</p>
<img src="https://luoochen.github.io/2022/07/04/3b1471531eae/image-20220730170202560.png" alt="image-20220730170202560" style="zoom:25%;">

<p>好了，比喻结束了。如果你有一点图论基础，相信你已经觉察到，这是一个<strong>树</strong>状的结构，要寻找集合的代表元素，只需要一层一层往上访问<strong>父节点</strong>（图中箭头所指的圆），直达树的<strong>根节点</strong>（图中橙色的圆）即可。根节点的父节点是它自己。我们可以直接把它画成一棵树：</p>
<img src="https://luoochen.github.io/2022/07/04/3b1471531eae/image-20220730170233096.png" alt="image-20220730170233096" style="zoom:25%;">

<p>用这种方法，我们可以写出<a href="#%E6%9C%B4%E7%B4%A0%E7%89%88%E6%9C%AC%E5%AE%9E%E7%8E%B0">朴素版本的并查集代码</a>。</p>
<h3 id="路径压缩版本"><a href="#路径压缩版本" class="headerlink" title="路径压缩版本"></a>路径压缩版本</h3><p>最简单的并查集效率是比较低的。例如，来看下面这个场景：</p>
<img src="https://luoochen.github.io/2022/07/04/3b1471531eae/image-20220730174101961.png" alt="image-20220730174101961" style="zoom:25%;">

<p>现在我们要merge(2,3)，于是从2找到1，fa[1]&#x3D;3，于是变成了这样：</p>
<img src="https://luoochen.github.io/2022/07/04/3b1471531eae/image-20220730174119618.png" alt="image-20220730174119618" style="zoom:25%;">

<p>然后我们又找来一个元素4，并需要执行merge(2,4)：</p>
<img src="https://luoochen.github.io/2022/07/04/3b1471531eae/image-20220730174222964.png" alt="image-20220730174222964" style="zoom:25%;">

<p>从2找到1，再找到3，然后fa[3]&#x3D;4，于是变成了这样：</p>
<img src="https://luoochen.github.io/2022/07/04/3b1471531eae/image-20220730174254579.png" alt="image-20220730174254579" style="zoom:25%;">

<p>大家应该有感觉了，这样可能会形成一条长长的<strong>链</strong>，随着链越来越长，我们想要从底部找到根节点会变得越来越难。</p>
<p>怎么解决呢？我们可以使用<strong>路径压缩</strong>的方法。既然我们只关心一个元素对应的<strong>根节点</strong>，那我们希望每个元素到根节点的路径尽可能短，最好只需要一步，像这样：</p>
<img src="https://luoochen.github.io/2022/07/04/3b1471531eae/image-20220730174348934.png" alt="image-20220730174348934" style="zoom: 33%;">

<p>其实这说来也很好实现。只要我们在查询的过程中，<strong>把沿途的每个节点的父节点都设为根节点</strong>即可。下一次再查询时，我们就可以省很多事。这<a href="#%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9%E7%89%88%E6%9C%AC%E5%AE%9E%E7%8E%B0">用递归的写法很容易实现</a>。</p>
<h3 id="按秩优化版本"><a href="#按秩优化版本" class="headerlink" title="按秩优化版本"></a>按秩优化版本</h3><p>路径压缩优化后，并查集的时间复杂度已经比较低了，绝大多数不相交集合的合并查询问题都能够解决。然而，对于某些时间卡得很紧的题目，我们还可以进一步优化。</p>
<p>有些人可能有一个误解，以为路径压缩优化后，并查集始终都是一个<strong>菊花图</strong>（只有两层的树的俗称）。但其实，由于路径压缩只在查询时进行，也只压缩一条路径，所以并查集最终的结构仍然可能是比较复杂的。例如，现在我们有一棵较复杂的树需要与一个单元素的集合合并：</p>
<img src="https://luoochen.github.io/2022/07/04/3b1471531eae/image-20220730180809432.png" alt="image-20220730180809432" style="zoom:33%;">

<p>假如这时我们要merge(7,8)，如果我们可以选择的话，是把7的父节点设为8好，还是把8的父节点设为7好呢？</p>
<p>当然是后者。因为如果把7的父节点设为8，会使树的<strong>深度</strong>（树中最长链的长度）加深，原来的树中每个元素到根节点的距离都变长了，之后我们寻找根节点的路径也就会相应变长。虽然我们有路径压缩，但路径压缩也是会消耗时间的。而把8的父节点设为7，则不会有这个问题，因为它没有影响到不相关的节点。</p>
<img src="https://luoochen.github.io/2022/07/04/3b1471531eae/image-20220730180833949.png" alt="image-20220730180833949" style="zoom:33%;">

<p>这启发我们：我们应该把简单的树往复杂的树上合并，而不是相反。因为这样合并后，到根节点距离变长的节点个数比较少。</p>
<p>我们用一个数组 <code>rank[]</code> 记录每个根节点对应的树的深度（如果不是根节点，其 <code>rank</code> 相当于以它作为根节点的<strong>子树</strong>的深度）。一开始，把所有元素的 <code>rank</code>（<strong>秩</strong>）设为1。合并时比较两个根节点，把 <code>rank</code> 较小者往较大者上合并。</p>
<p>路径压缩和按秩合并如果一起使用，时间复杂度接近 $ O(\alpha(n)) $，但是很可能会破坏 <code>rank</code> 的准确性。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="朴素版本实现"><a href="#朴素版本实现" class="headerlink" title="朴素版本实现"></a>朴素版本实现</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>假如有编号为0,1, 2, 3, …, n-1的n个元素，我们用一个数组fa[]来存储每个元素的父节点（因为每个元素有且只有一个父节点，所以这是可行的）。一开始，我们先将它们的父节点设为自己。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fa<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token function">UnionFindSimple</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// init</span>
    fa <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        fa<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>我们用递归的写法实现对代表元素的查询：一层一层访问父节点，直至根节点（根节点的标志就是父节点是本身）。要判断两个元素是否属于同一个集合，只需要看它们的根节点是否相同即可。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">==</span> x<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> x<span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">find</span><span class="token punctuation">(</span>fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><p>合并操作也是很简单的，先找到两个集合的代表元素，然后将前者的父节点设为后者即可。当然也可以将后者的父节点设为前者，这里暂时不重要。<a href="#%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9%E7%89%88%E6%9C%AC%E5%AE%9E%E7%8E%B0">路径压缩版本实现</a>会给出一个更合理的比较方法。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    fa<span class="token punctuation">[</span><span class="token function">find</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><p>省略</p>
<h3 id="路径压缩版本实现"><a href="#路径压缩版本实现" class="headerlink" title="路径压缩版本实现"></a>路径压缩版本实现</h3><blockquote>
<p>其他内容参考<a href="#%E6%9C%B4%E7%B4%A0%E7%89%88%E6%9C%AC%E5%AE%9E%E7%8E%B0">朴素版本实现</a></p>
</blockquote>
<h4 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h4><p>在查询的过程中，<strong>把沿途的每个节点的父节点都设为根节点</strong>即可。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * Path compression
 * @param x
 * @return
 */</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">==</span> x<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> x<span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="按秩优化版本实现"><a href="#按秩优化版本实现" class="headerlink" title="按秩优化版本实现"></a>按秩优化版本实现</h3><blockquote>
<p>其他内容参考<a href="#%E6%9C%B4%E7%B4%A0%E7%89%88%E6%9C%AC%E5%AE%9E%E7%8E%B0">朴素版本实现</a></p>
</blockquote>
<h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fa<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rank<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token function">UnionFindSimpleUnionByRank</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// init</span>
    fa <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    rank <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        fa<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
        rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="合并-1"><a href="#合并-1" class="headerlink" title="合并"></a>合并</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//先找到两个根节点</span>
    <span class="token keyword">int</span> rooti <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> rootj <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>rooti <span class="token operator">==</span> rootj<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>rank<span class="token punctuation">[</span>rooti<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> rank<span class="token punctuation">[</span>rootj<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        fa<span class="token punctuation">[</span>rooti<span class="token punctuation">]</span> <span class="token operator">=</span> rootj<span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        fa<span class="token punctuation">[</span>rootj<span class="token punctuation">]</span> <span class="token operator">=</span> rooti<span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//如果深度相同且根节点不同，则新的根节点的深度+1</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>rank<span class="token punctuation">[</span>rooti<span class="token punctuation">]</span> <span class="token operator">==</span> rank<span class="token punctuation">[</span>rootj<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        rank<span class="token punctuation">[</span>rootj<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为什么深度相同，新的根节点深度要+1？如下图，我们有两个深度均为2的树，现在要merge(2,5)：</p>
<img src="https://luoochen.github.io/2022/07/04/3b1471531eae/image-20220730184313928.png" alt="image-20220730184313928" style="zoom:25%;">

<p>这里把2的父节点设为5，或者把5的父节点设为2，其实没有太大区别。我们选择前者，于是变成这样：</p>
<img src="https://luoochen.github.io/2022/07/04/3b1471531eae/image-20220730184332328.png" alt="image-20220730184332328" style="zoom:25%;">

<p>显然树的深度增加了1。另一种合并方式同样会让树的深度+1。</p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>容易看出，并查集的空间复杂度是 $O(n)$</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>对于同时使用路径压缩和按秩合并优化的并查集，每个查询和合并操作的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B9%B3%E6%91%8A%E5%88%86%E6%9E%90">平均</a>时间复杂度仅为 $O(\alpha(n))$，$O(\alpha(n))$ 是反阿克曼函数。由于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%98%BF%E5%85%8B%E6%9B%BC%E5%87%BD%E6%95%B0">阿克曼函数</a>增加极度迅速，所以 $\alpha(n)$ 增长极度缓慢，对于任何在实践中有意义的元素数目 $n$,  $\alpha(n)$ 均小于5，因此，也可以粗略地认为，并查集的操作有常数的时间复杂度。</p>
<p>实际上，这是渐近最优算法：Fredman 和 Saks 在 1989 年证明了任何并查集都需要 $\Omega (\alpha (n))$  的均摊时间来完成每次操作。</p>
</p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></span><span class="soc"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></span><span class="soc"><a target="_blank" rel="noopener" href="http://twitter.com/home?status=https://luoochen.github.io/2022/07/04/3b1471531eae/%20风吹流年远%20并查集" class="fa fa-twitter"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/2022/08/23/87178ab5d221/" title="Hello World"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: Hello World</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/2022/07/04/874b2383dc4b/" title="跳表">Next post: 跳表&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2022&nbsp;<a target="_blank" href="https://luoochen.github.io" rel="noopener noreferrer">Luoo</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>